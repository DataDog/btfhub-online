package handlers

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/gin-gonic/gin"

	"github.com/seek-ret/btfhub-online/internal/btfarchive"
	"github.com/seek-ret/btfhub-online/internal/datatypes"
)

// RoutesHandler is the implementation for all handlers of the BTFHub online server.
type RoutesHandler struct {
	archive  btfarchive.Archive
	toolsDir string
}

// NewRoutesHandler returns a new instance of the RoutesHandler.
func NewRoutesHandler(archive btfarchive.Archive, toolsDir string) RoutesHandler {
	return RoutesHandler{
		archive:  archive,
		toolsDir: toolsDir,
	}
}

// ListBTFs returns a list of all available BTFs from the archive.
func (routesHandler RoutesHandler) ListBTFs(ginContext *gin.Context) {
	btfs, err := routesHandler.archive.List(ginContext)
	if err != nil {
		_ = ginContext.AbortWithError(http.StatusInternalServerError, err)
		return
	}
	ginContext.JSON(http.StatusOK, btfs)
}

// ListBTFsLegacy returns a list of all available BTFs from the archive in a legacy format of string array of paths in
// the archive.
func (routesHandler RoutesHandler) ListBTFsLegacy(ginContext *gin.Context) {
	btfs, err := routesHandler.archive.List(ginContext)
	if err != nil {
		_ = ginContext.AbortWithError(http.StatusInternalServerError, err)
		return
	}
	stringList := make([]string, len(btfs))
	for i, btf := range btfs {
		stringList[i] = fmt.Sprintf("%s/%s/%s/%s.btf.tar.xz", btf.Distribution, btf.DistributionVersion, btf.Arch, btf.KernelVersion)
	}
	ginContext.JSON(http.StatusOK, btfs)
}

// DownloadBTF receives upon the query variables the BTFRecordIdentifier and download the BTF as is from the acrhive.
func (routesHandler RoutesHandler) DownloadBTF(ginContext *gin.Context) {
	var identifier datatypes.BTFRecordIdentifier
	if err := ginContext.BindQuery(&identifier); err != nil {
		_ = ginContext.AbortWithError(http.StatusBadRequest, err)
		return
	}

	reader, size, err := routesHandler.archive.Download(ginContext, identifier)
	if err != nil {
		_ = ginContext.AbortWithError(http.StatusInternalServerError, err)
		return
	}
	ginContext.DataFromReader(http.StatusOK, size, "application/octet-stream", reader, map[string]string{
		"Content-Description":       "File Transfer",
		"Content-Transfer-Encoding": "binary",
	})
}

// generateBTFs is internal function that should be merged into CustomizeBTF when CustomizeBTFLegacy is being deleted.
// It extracts the bpf binary from the request, and generates a custom BTF for the BTF that fits the given filter.
func (routesHandler RoutesHandler) generateBTFs(context *gin.Context, filter string) {
	// Read the BPF binary from the HTTP payload.
	bpfReader, err := context.FormFile("bpf")
	if err != nil {
		log.Printf("Failed reading BPF from request: %+v", err)
		_ = context.AbortWithError(http.StatusBadRequest, err)
		return
	}

	// Create a local temporary file to hold the BPF binary content.
	bpfFile, err := ioutil.TempFile("", "bpf")
	if err != nil {
		log.Printf("Failed creating temporary file for the BPF: %+v", err)
		context.AbortWithStatus(http.StatusInternalServerError)
		return
	}
	defer os.Remove(bpfFile.Name())

	reader, err := bpfReader.Open()
	if err != nil {
		log.Printf("Failed reading BPF reader: %+v", err)
		context.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	// Write the BPF binary to the temporary file.
	if _, err := io.Copy(bpfFile, reader); err != nil {
		log.Printf("Failed copy BPF to the temporary file: %+v", err)
		context.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	// Create a temporary directory that will hold the BTFs we generate.
	dir, err := ioutil.TempDir("", "btf")
	if err != nil {
		log.Printf("Failed creating temporary directory for BTFs: %+v", err)
		context.AbortWithStatus(http.StatusInternalServerError)
		return
	}
	defer os.RemoveAll(dir)

	// Run the btfgen script that gets BPF file path, and a filter for kernels, the script will generate BTF for every
	// kernel in the bucket that matches to the filter.
	// The outcome will be a tar-gz of all the minimized BTFs for the given BPF.
	//nolint:gosec
	command := exec.Command(fmt.Sprintf("%s/btfgen.sh", routesHandler.toolsDir), bpfFile.Name(), filter)
	var out bytes.Buffer
	var stderr bytes.Buffer
	command.Stdout = &out
	command.Stderr = &stderr
	command.Dir = dir
	if err := command.Run(); err != nil {
		log.Printf("Failed creating BTFs for a given BPF due to: %+v", err)
		log.Printf("Output log: %s", stderr.String())
		context.AbortWithStatus(http.StatusInternalServerError)
		return
	}
	// Sending the btfs.tar.gz file generated by the btfgen.sh script.
	context.Header("Content-Description", "File Transfer")
	context.Header("Content-Transfer-Encoding", "binary")
	context.Header("Content-Disposition", "attachment; filename=btfs.tar.gz")
	context.Header("Content-Type", "application/octet-stream")
	context.File(filepath.Join(dir, "btfs.tar.gz"))
}

// CustomizeBTFLegacy wraps generateBTFs for legacy interface (receives the BTF path in the archive using `kernel_name`).
func (routesHandler RoutesHandler) CustomizeBTFLegacy(ginContext *gin.Context) {
	kernelName := ginContext.Query("kernel_name")
	if kernelName == "" {
		ginContext.AbortWithStatusJSON(http.StatusBadRequest, "missing kernel_name query param")
		return
	}

	kernelName = strings.ReplaceAll(kernelName, "*", "")
	if !strings.HasSuffix(kernelName, ".btf.tar.xz") {
		kernelName += ".btf.tar.xz"
	}

	routesHandler.generateBTFs(ginContext, kernelName)
}

// CustomizeBTF wraps generateBTFs to reduce code duplication with CustomizeBTFLegacy.
// Receives the BTF identifier from query parameters and returns the customized BTF for the given BPF.
func (routesHandler RoutesHandler) CustomizeBTF(ginContext *gin.Context) {
	var identifier datatypes.BTFRecordIdentifier
	if err := ginContext.BindQuery(&identifier); err != nil {
		_ = ginContext.AbortWithError(http.StatusInternalServerError, err)
		return
	}

	routesHandler.generateBTFs(ginContext, fmt.Sprintf("%s/%s/%s/%s.btf.tar.xz", identifier.Distribution, identifier.DistributionVersion, identifier.Arch, identifier.KernelVersion))
}
