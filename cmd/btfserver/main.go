package main

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"cloud.google.com/go/storage"
	"github.com/gin-gonic/gin"
	"google.golang.org/api/iterator"

	"github.com/seek-ret/btfhub-online/internal/env"
)

const (
	defaultPort = "8080"
)

var (
	toolsDir string
)

func init() {
	var err error
	toolsDir, err = env.GetAbsolutePathFromEnv("TOOLS_DIR")
	if err != nil {
		log.Fatal(err)
	}
}

func generateBTFs(context *gin.Context, filter string) {
	// Read the BPF binary from the HTTP payload.
	bpfReader, err := context.FormFile("bpf")
	if err != nil {
		log.Printf("Failed reading BPF from request: %+v", err)
		context.AbortWithError(http.StatusBadRequest, errors.New("failed reading BPF from request"))
		return
	}

	// Create a local temporary file to hold the BPF binary content.
	bpfFile, err := ioutil.TempFile("", "bpf")
	if err != nil {
		log.Printf("Failed creating temporary file for the BPF: %+v", err)
		context.AbortWithStatus(http.StatusInternalServerError)
		return
	}
	defer os.Remove(bpfFile.Name())

	reader, err := bpfReader.Open()
	if err != nil {
		log.Printf("Failed reading BPF reader: %+v", err)
		context.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	// Write the BPF binary to the temporary file.
	if _, err := io.Copy(bpfFile, reader); err != nil {
		log.Printf("Failed copy BPF to the temporary file: %+v", err)
		context.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	// Create a temporary directory that will hold the BTFs we generate.
	dir, err := ioutil.TempDir("", "btf")
	if err != nil {
		log.Printf("Failed creating temporary directory for BTFs: %+v", err)
		context.AbortWithStatus(http.StatusInternalServerError)
		return
	}
	defer os.RemoveAll(dir)

	// Run the btfgen script that gets BPF file path, and a filter for kernels, the script will generate BTF for every
	// kernel in the bucket that matches to the filter.
	// The outcome will be a tar-gz of all the minimized BTFs for the given BPF.
	//nolint:gosec
	command := exec.Command(fmt.Sprintf("%s/btfgen.sh", toolsDir), bpfFile.Name(), filter)
	var out bytes.Buffer
	var stderr bytes.Buffer
	command.Stdout = &out
	command.Stderr = &stderr
	command.Dir = dir
	if err := command.Run(); err != nil {
		log.Printf("Failed creating BTFs for a given BPF due to: %+v", err)
		log.Printf("Output log: %s", stderr.String())
		context.AbortWithStatus(http.StatusInternalServerError)
		return
	}
	// Sending the btfs.tar.gz file generated by the btfgen.sh script.
	context.Header("Content-Description", "File Transfer")
	context.Header("Content-Transfer-Encoding", "binary")
	context.Header("Content-Disposition", "attachment; filename=btfs.tar.gz")
	context.Header("Content-Type", "application/octet-stream")
	context.File(filepath.Join(dir, "btfs.tar.gz"))
}

func generateSingleBTF(context *gin.Context) {
	kernelName := context.Query("kernel_name")
	if kernelName == "" {
		context.AbortWithStatusJSON(http.StatusBadRequest, "missing kernel_name query param")
		return
	}

	generateBTFs(context, kernelName)
}

func generateBTFHub(context *gin.Context) {
	generateBTFs(context, "")
}

func listBTFs(ginContext *gin.Context) {
	ctx := context.Background()
	client, err := storage.NewClient(ctx)
	if err != nil {
		ginContext.AbortWithError(500, err)
		return
	}

	btfhubBucket := client.Bucket("btfhub")
	iter := btfhubBucket.Objects(ctx, nil)
	res := make([]string, 0)
	for {
		attrs, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			log.Printf("Bucket(btfhub).Objects: %v", err)
			continue
		}

		if strings.HasSuffix(attrs.Name, ".btf.tar.xz") {
			res = append(res, attrs.Name)
		}
	}

	ginContext.JSON(http.StatusOK, res)
}

func main() {
	engine := gin.New()

	engine.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
		return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s \"%s\" %s\"\n",
			param.ClientIP,
			param.TimeStamp.Format(time.RFC1123),
			param.Method,
			param.Path,
			param.Request.Proto,
			param.StatusCode,
			param.Latency,
			param.Request.UserAgent(),
			param.ErrorMessage,
		)
	}))
	engine.Use(gin.Recovery())
	engine.POST("/generate", generateSingleBTF)
	engine.GET("/list", listBTFs)
	engine.POST("/generate-hub", generateBTFHub)

	port := os.Getenv("PORT")
	if port == "" {
		port = defaultPort
	}

	fmt.Printf("listening on 0.0.0.0:%s\n", port)
	if err := engine.Run(fmt.Sprintf("0.0.0.0:%s", port)); err != nil {
		log.Fatal(err)
	}
}
